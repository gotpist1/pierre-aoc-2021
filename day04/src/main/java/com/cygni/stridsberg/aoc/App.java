/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.cygni.stridsberg.aoc;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.IntStream;


public class App {
    private final List<String> input;

    public App(List<String> input) {
        this.input = input;
    }

    public static void main(String[] args) throws IOException {
        System.out.println("java");
        List<String> input = parseInput("input.txt");

        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2")) {
            System.out.println(new App(input).getSolutionPart2());
        } else {
            System.out.println(new App(input).getSolutionPart1());
        }
    }

    private static List<String> parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename))
            .collect(Collectors.toList());
    }

    public Integer getSolutionPart1() {
        var numbersToDraw = getDrawnNumbersList();
        input.remove(0);
        var rowChunks = chunk(getTrimmedRows(), 5);
        List<Board[][]> boards = getBoardsList(rowChunks);
        return findWinningTicket(numbersToDraw, boards);
    }

    public Integer getSolutionPart2() {
        var numbersToDraw = getDrawnNumbersList();
        input.remove(0);
        var rowChunks = chunk(getTrimmedRows(), 5);
        List<Board[][]> boards = getBoardsList(rowChunks);
        return findLastWinningTicket(numbersToDraw, boards);
    }

    private int findWinningTicket(List<String> numbersToDraw, List<Board[][]> input) {
        return findRightBoard(numbersToDraw, input, i -> i == 1);
    }

    private int findLastWinningTicket(List<String> numbersToDraw, List<Board[][]> input) {
        return findRightBoard(numbersToDraw, input, i -> input.size() == i);
    }

    private Integer findRightBoard(List<String> numbersToDraw, List<Board[][]> input, Predicate<Integer> stopPredicate) {
        record WinningBoard(int winningNumber, Board[][] winningBoard, int boardIndex) {
        }
        List<WinningBoard> winningBoards = new ArrayList<>();
        for (String number : numbersToDraw) {
            var drawnNumber = Integer.parseInt(number);
            for (int boardArrayIndex = 0; boardArrayIndex < input.size(); boardArrayIndex++) {
                var currentBoard = input.get(boardArrayIndex);
                for (int rowIndex = 0; rowIndex < currentBoard.length; rowIndex++) {
                    for (int valueIndex = 0; valueIndex < currentBoard[0].length; valueIndex++) {
                        if (currentBoard[rowIndex][valueIndex].getNumber().equals(number)) {
                            currentBoard[rowIndex][valueIndex].setMarked();
                        }
                    }
                }
                int finalBoardArrayIndex = boardArrayIndex;
                var boardAtIndex =
                    winningBoards.stream().filter(b -> b.boardIndex == finalBoardArrayIndex)
                        .findFirst()
                        .orElseGet(() -> new WinningBoard(0, null, 0));
                if (isWinningBoard(currentBoard) && !winningBoards.contains(boardAtIndex)) {
                    winningBoards.add(new WinningBoard(drawnNumber, currentBoard, boardArrayIndex));
                    if (stopPredicate.test(winningBoards.size())) {
                        var lastWinningBoard = winningBoards.get(winningBoards.size() - 1);
                        return getNoHitSum(lastWinningBoard.winningBoard) * lastWinningBoard.winningNumber;
                    }
                }
            }
        }
        return 0;
    }

    private int getNoHitSum(Board[][] input) {
        return Arrays.stream(input).flatMap(Arrays::stream)
            .filter(board -> !board.getmarked())
            .map(Board::getNumber)
            .mapToInt(Integer::parseInt)
            .sum();
    }

    private boolean isWinningBoard(Board[][] input) {
        for (int i = 0; i < input.length; i++) {
            if (allRowMatch(input[i]) || allColumnMatch(input, i)) {
                return true;
            }
        }
        return false;
    }

    private boolean allColumnMatch(Board[][] input, int index) {
        return Arrays.stream(input).allMatch(val -> val[index].getmarked());
    }

    private boolean allRowMatch(Board[] array) {
        return Arrays.stream(array).allMatch(Board::getmarked);
    }

    private List<Board[][]> getBoardsList(String[][] rowChunks) {
        List<Board[][]> boards = new ArrayList<>();
        for (int i = 0; i < rowChunks.length; i++) {
            Board[][] board = new Board[5][5];
            for (int j = 0; j < rowChunks[i].length; j++) {
                var newArr = rowChunks[i][j].split("\\s+");
                for (int k = 0; k < newArr.length; k++) {
                    board[j][k] = new Board(newArr[k].trim().strip());
                }
            }
            boards.add(board);
        }
        return boards;
    }

    private String[] getTrimmedRows() {
        String[] rows = input.stream()
            .filter(s -> !s.isEmpty())
            .toArray(String[]::new);
        String[] trimmedRows = new String[rows.length];
        for (int i = 0; i < rows.length; i++) {
            trimmedRows[i] = rows[i].strip().trim();
        }
        return trimmedRows;
    }

    private List<String> getDrawnNumbersList() {
        return Arrays
            .stream(input.get(0).split(","))
            .collect(Collectors.toList());
    }

    public String[][] chunk(String[] input, int chunkSize) {
        return IntStream.iterate(0, i -> i + chunkSize)
            .limit((long) Math.ceil((double) input.length / chunkSize))
            .mapToObj(j -> Arrays.copyOfRange(input, j, Math.min(j + chunkSize, input.length)))
            .toArray(String[][]::new);
    }

    static class Board {
        private final String number;
        private boolean marked;

        Board(String num) {
            this.number = num;
            this.marked = false;
        }

        public String getNumber() {
            return this.number;
        }

        public boolean getmarked() {
            return this.marked;
        }

        public void setMarked() {
            this.marked = true;
        }
    }
}
