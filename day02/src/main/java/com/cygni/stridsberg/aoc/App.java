/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.cygni.stridsberg.aoc;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;


public class App {
    private final List<String> input;

    public App(List<String> input) {
        this.input = input;
    }

    public static void main(String[] args) throws IOException {
        System.out.println("java");
        List<String> input = parseInput("input.txt");

        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2")) {
            System.out.println(new App(input).getSolutionPart2());
        } else {
            System.out.println(new App(input).getSolutionPart1());
        }
    }

    private static List<String> parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename))
            .collect(Collectors.toList());
    }

    public Integer getSolutionPart1() {
        AtomicInteger depth = new AtomicInteger(0);
        AtomicInteger horizontal = new AtomicInteger(0);
        var commandsList = input.stream()
            .map(line -> line.split(" "))
            .map(this::mapToCommands)
            .collect(Collectors.toList());
        commandsList.forEach(c -> {
            switch (c.command) {
                case UP, DOWN -> depth.getAndSet(c.command.calculateValue(depth.get(), c.value));
                case FORWARD -> horizontal.getAndSet(c.command.calculateValue(horizontal.get(), c.value));
            }
        });

        return depth.get() * horizontal.get();
    }

    public Integer getSolutionPart2() {
        AtomicInteger depth = new AtomicInteger(0);
        AtomicInteger horizontal = new AtomicInteger(0);
        AtomicInteger aim = new AtomicInteger(0);
        var commandsList = input.stream()
            .map(line -> line.split(" "))
            .map(this::mapToCommands)
            .collect(Collectors.toList());
        commandsList.forEach(c -> {
            switch (c.command) {
                case UP, DOWN -> aim.getAndSet(c.command.calculateValue(aim.get(), c.value));
                case FORWARD -> {
                    horizontal.getAndSet(c.command.calculateValue(horizontal.get(), c.value));
                    if (aim.get() != 0) {
                        depth.getAndSet( depth.get() + (c.value * aim.get()));
                    }
                }
            }
        });
        return depth.get() * horizontal.get();
    }

    private Commands mapToCommands(String[] line) {
        return new Commands(CommandTypes.valueOf(line[0].toUpperCase()), Integer.parseInt(line[1]));
    }

    record Commands(CommandTypes command, int value) {
    }

    private enum CommandTypes {
        UP {
            @Override
            public int calculateValue(int currentValue, int value) {
                return currentValue - value;
            }
        }, DOWN {
            @Override
            public int calculateValue(int currentValue, int value) {
                return currentValue + value;
            }
        }, FORWARD {
            @Override
            public int calculateValue(int currentValue, int value) {
                return currentValue + value;
            }
        };

        public abstract int calculateValue(int currentValue, int value);
    }
}
