/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.cygni.stridsberg.aoc;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;


public class App {
    private final List<String> input;

    public App(List<String> input) {
        this.input = input;
    }

    public static void main(String[] args) throws IOException {
        System.out.println("java");
        List<String> input = parseInput("input.txt");

        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2")) {
            System.out.println(new App(input).getSolutionPart2());
        } else {
            System.out.println(new App(input).getSolutionPart1());
        }
    }

    private static List<String> parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename))
            .collect(Collectors.toList());
    }


    public Integer getSolutionPart1() {
        List<Integer> validLengths = List.of(3, 4, 7, 2);
        var t = input.stream().map(s -> s.substring(s.indexOf("|") + 1))
            .filter(s -> !s.isEmpty())
            .map(s -> s.split("\\s+"))
            .flatMap(Arrays::stream)
            .filter(s -> validLengths.contains(s.length()))
            .count();
        System.out.println(t);
        return 1;
    }

    public Integer getSolutionPart2() {
        Map<String, String> numberMap = Map.of("012345", "0", "12", "1", "01346", "2", "01236", "3", "1256", "4", "02356",
            "5", "023456", "6", "012", "7", "0123456", "8",
            "012356", "9");
        List<String> outputEntries = new ArrayList<>();
        var patternsList = input
            .stream()
            .map(this::mapToSignalPatternAndCode).collect(Collectors.toList());

        for (SignalPatternAndCode signalPatternAndCode : patternsList) {
            Map<String, Integer> foundNumbers = new HashMap<>();
            Map<String, String> segmentsMap = new HashMap<>();
            signalPatternAndCode.signalPatterns().forEach(signalPattern -> {
                switch (signalPattern.length()) {
                    case 2 -> foundNumbers.put(signalPattern, 1);
                    case 3 -> foundNumbers.put(signalPattern, 7);
                    case 4 -> foundNumbers.put(signalPattern, 4);
                    case 7 -> foundNumbers.put(signalPattern, 8);
                }
            });
            String one = getSpecificNumber(foundNumbers, 1);
            String eight = getSpecificNumber(foundNumbers, 8);
            String four = getSpecificNumber(foundNumbers, 4);
            String seven = getSpecificNumber(foundNumbers, 7);
            String zeroSegmentIndex = "", oneSegmentIndex = "", twoSegmentIndex = "", threeSegmentIndex = "", fourthSegmentIndex = "", fiveSegmentIndex =
                "", sixthSegmentIndex = "";
            zeroSegmentIndex = findDiff(seven, one).orElseThrow();
            segmentsMap.put(zeroSegmentIndex, "0");

            var allWithSixSegments =
                signalPatternAndCode.signalPatterns().stream().filter(p -> p.length() == 6).collect(Collectors.toList());

            for (String pattern : allWithSixSegments) {
                var sevenDiff = findDiff(seven, pattern);
                var fourDiff = findDiff(four, pattern);
                if (sevenDiff.isPresent() && fourDiff.isPresent() && sevenDiff.get().equals(fourDiff.get()) &&
                    !foundNumbers.containsKey(pattern)) {
                    foundNumbers.put(pattern, 6);
                    oneSegmentIndex = sevenDiff.get();
                    segmentsMap.put(oneSegmentIndex, "1");
                }
            }
            var zeroAndOneSeg = zeroSegmentIndex + oneSegmentIndex;
            twoSegmentIndex = findDiff(seven, zeroAndOneSeg).orElseThrow();
            segmentsMap.put(twoSegmentIndex, "2");
            for (String pattern : allWithSixSegments) {
                var eightDiff = findDiff(eight, pattern);
                var fourDiff = findDiff(four, pattern);
                if (eightDiff.isPresent() && fourDiff.isPresent() && eightDiff.get().equals(fourDiff.get())) {
                    if (!foundNumbers.containsKey(pattern)) {
                        foundNumbers.put(pattern, 0);
                        sixthSegmentIndex = findDiff(eight, pattern).orElseThrow();
                        segmentsMap.put(sixthSegmentIndex, "6");
                        fiveSegmentIndex = four.codePoints()
                            .mapToObj(c -> String.valueOf((char) c))
                            .filter(c -> !segmentsMap.containsKey(c))
                            .findFirst().orElseThrow();
                        segmentsMap.put(fiveSegmentIndex, "5");
                    }
                }
            }
            for (String pattern : allWithSixSegments) {
                if (!foundNumbers.containsKey(pattern)) {
                    foundNumbers.put(pattern, 9);
                    fourthSegmentIndex = findDiff(eight, pattern).orElseThrow();
                    segmentsMap.put(fourthSegmentIndex, "4");
                }
            }
            threeSegmentIndex = eight.codePoints()
                .mapToObj(c -> String.valueOf((char) c))
                .filter(c -> !segmentsMap.containsKey(c))
                .findFirst().orElseThrow();
            segmentsMap.put(threeSegmentIndex, "3");
            StringBuilder builder = new StringBuilder();
            for (String code : signalPatternAndCode.codes()) {
                var currentCode = code.codePoints()
                    .mapToObj(c -> String.valueOf((char) c))
                    .map(segmentsMap::get)
                    .sorted()
                    .collect(Collectors.joining());
                var number = numberMap.get(currentCode);
                builder.append(number);
            }
            outputEntries.add(builder.toString());

        }
        return outputEntries.stream().mapToInt(Integer::parseInt).sum();
    }

    private SignalPatternAndCode mapToSignalPatternAndCode(String inputLine) {
        var signalsAndCodes = inputLine.split("\\|");
        return new SignalPatternAndCode(stringToList(signalsAndCodes[0]), stringToList(signalsAndCodes[1]));
    }

    private String getSpecificNumber(Map<String, Integer> foundNumbers, int i) {
        return foundNumbers.entrySet().stream().filter(e -> e.getValue() == i).map(Map.Entry::getKey).findFirst().orElseThrow();
    }

    private List<String> stringToList(String value) {
        return Arrays.stream(value.split("\\s+"))
            .filter(val -> !val.isEmpty())
            .collect(Collectors.toList());
    }

    record SignalPatternAndCode(List<String> signalPatterns, List<String> codes) {
    }

    private Optional<String> findDiff(String a, String b) {
        var tmp = b.codePoints()
            .mapToObj(c -> String.valueOf((char) c))
            .collect(Collectors.toList());
        return a.codePoints()
            .mapToObj(c -> String.valueOf((char) c))
            .filter(s -> !tmp.contains(s))
            .findFirst();
    }
}
